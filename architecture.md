# Архитектура системы автоматического сбора данных Facebook Ad Spend

## Введение

Данный документ описывает предлагаемую архитектуру системы для автоматизированного сбора данных о расходах на рекламу (ad spend) и идентификаторах объявлений (ad.id) с нескольких аккаунтов Facebook. Ключевой особенностью системы является использование антидетект-браузеров для имитации реального пользователя и обхода механизмов обнаружения ботов Facebook, что позволяет безопасно и эффективно собирать данные без риска блокировки аккаунтов. Система будет работать в автоматическом режиме по расписанию (cron).

## Обзор архитектуры

Предлагаемая архитектура представляет собой модульную систему, состоящую из нескольких ключевых компонентов, взаимодействующих друг с другом для выполнения поставленной задачи. Основная идея заключается в том, чтобы каждый запрос к Facebook API выполнялся через отдельный профиль антидетект-браузера, который содержит уникальные параметры (прокси, куки, отпечатки браузера), соответствующие реальному пользовательскому сеансу. Это минимизирует вероятность обнаружения автоматизированной активности.

## Компоненты системы

Система будет состоять из следующих основных компонентов:

1.  **Менеджер профилей антидетект-браузера (Anti-Detect Browser Profile Manager)**: Этот компонент отвечает за управление профилями антидетект-браузера. Он будет взаимодействовать с API антидетект-браузера для запуска, остановки, создания и удаления профилей. Каждый профиль будет содержать уникальные данные, такие как прокси, куки, отпечатки браузера и другие параметры, необходимые для имитации реального пользователя.

2.  **Модуль взаимодействия с Facebook Graph API (Facebook Graph API Interaction Module)**: Этот модуль будет отвечать за формирование и отправку запросов к Facebook Graph API для получения данных о расходах на рекламу и ad.id. Важно, что все запросы будут маршрутизироваться через соответствующий профиль антидетект-браузера, чтобы Facebook видел запросы, исходящие от 


реального пользователя с соответствующими прокси, куками и отпечатками.

3.  **Модуль хранения данных (Data Storage Module)**: Этот модуль будет отвечать за хранение собранных данных о расходах на рекламу и ad.id. Это может быть реляционная база данных (например, PostgreSQL, MySQL) для структурированного хранения данных, или NoSQL база данных (например, MongoDB) для более гибкого хранения. Выбор будет зависеть от объема данных и требований к их анализу. Данные будут храниться с привязкой к ad.id, диапазону времени и профилю Facebook.

4.  **Планировщик (Scheduler)**: Этот компонент будет отвечать за запуск скрипта по расписанию. Для этого будет использоваться `cron` (для Linux-систем) или аналогичные инструменты планирования задач. Планировщик будет запускать главный скрипт системы с заданной периодичностью (например, раз в день, раз в час).

5.  **Оркестратор (Orchestrator)**: Это центральный компонент системы, который координирует работу всех остальных модулей. Он будет отвечать за:
    *   Чтение списка профилей Facebook из конфигурационного файла или базы данных.
    *   Инициализацию и запуск антидетект-браузера для каждого профиля.
    *   Вызов модуля взаимодействия с Facebook Graph API для каждого профиля, передавая необходимые параметры (диапазон времени, ad.id).
    *   Обработку ответов от Facebook API и передачу данных в модуль хранения данных.
    *   Обработку ошибок и логирование.

## Взаимодействие компонентов

1.  **Начало работы**: Планировщик (`cron`) запускает скрипт Оркестратора по заданному расписанию.
2.  **Загрузка профилей**: Оркестратор загружает список профилей Facebook, каждый из которых ассоциирован с уникальными параметрами антидетект-браузера (ID профиля, прокси, куки, отпечатки).
3.  **Итерация по профилям**: Для каждого профиля:
    *   Оркестратор через API антидетект-браузера запускает соответствующий профиль.
    *   Модуль взаимодействия с Facebook Graph API, используя запущенный профиль антидетект-браузера, отправляет запросы к Facebook API для получения данных о расходах.
    *   Полученные данные передаются в Модуль хранения данных для сохранения.
    *   После завершения сбора данных для текущего профиля, Оркестратор через API антидетект-браузера закрывает профиль.
4.  **Завершение**: После обработки всех профилей, Оркестратор завершает свою работу до следующего запуска по расписанию.

## Преимущества предлагаемой архитектуры

*   **Имитация реального пользователя**: Использование антидетект-браузеров для каждого профиля Facebook позволяет максимально имитировать поведение реального пользователя, что значительно снижает риск блокировки аккаунтов.
*   **Масштабируемость**: Архитектура позволяет легко добавлять новые профили Facebook и масштабировать систему для обработки большого количества аккаунтов.
*   **Автоматизация**: Полная автоматизация процесса сбора данных с помощью `cron` исключает необходимость ручного вмешательства.
*   **Гибкость**: Модульная структура позволяет легко заменять или модифицировать отдельные компоненты без влияния на всю систему (например, сменить антидетект-браузер или базу данных).

## Технологический стек (предварительный)

*   **Язык программирования**: Python (для скриптов Оркестратора и модулей взаимодействия).
*   **Антидетект-браузер**: Любой антидетект-браузер с API (например, Dolphin Anty, AdsPower, Undetectable.io).
*   **Взаимодействие с Facebook API**: `facebook-sdk` или `requests` для HTTP-запросов.
*   **Хранение данных**: PostgreSQL/MySQL или MongoDB.
*   **Планирование задач**: `cron` (Linux).

## Заключение

Предложенная архитектура обеспечивает надежный и масштабируемый подход к автоматизированному сбору данных о расходах на рекламу в Facebook. Следующим шагом будет детальное проектирование каждого модуля и разработка технического плана реализации.

